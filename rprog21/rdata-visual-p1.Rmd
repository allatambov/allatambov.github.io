---
title: "Основы программирования в R"
subtitle: "Визуализация данных в R: часть 1"
author: "Алла Тамбовцева, НИУ ВШЭ"
output:
  pdf_document: 
    toc: true
  html_document:
    df_print: paged
header-includes:
- \usepackage[russian]{babel}
- \usepackage{graphics}
- \usepackage{hyperref}
- \hypersetup{colorlinks = true, urlcolor = blue, linkcolor = magenta}
---

Загрузим данные из файла `tree` с учетом кодировки и вида ячеек с пропущенными значениями и удалим строки с `NA`:

```{r}
tree <- read.csv("/Users/allat/Desktop/firtree.csv", 
                 encoding = "UTF-8", na.strings = "")
tree <- na.omit(tree)
```

## Визуализация качественных данных: столбиковая диаграмма

Построим столбиковую диаграмму (*bar plot* или *bar chart*) для столбца `ftype`. Но для начала вспомним, сколько в этом столбце уникальных значений, чтобы представлять, как будет выглядеть график: 

```{r}
unique(tree$ftype)
```

Воспользуемся функцией `barplot()`. Добавим заголовок к графику (аргумент `main`), подписи к горизонтальной и вертикальной оси (`xlab` и `ylab`) и вектор цветов для столбцов (`col`):

```{r, eval=FALSE}
barplot(table(tree$ftype), 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев", ylab = "Частота")
```

```{r, include=FALSE}
dev.copy(png, "barplot1.png")
barplot(table(tree$ftype), 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев", ylab = "Частота")
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{barplot1.png}
\end{figure}

А теперь сделаем ось $Oy$ более детальной – добавим побольше делений. Для ручной корректировки осей есть специальная функция `axis()`, где первым аргументом идёт номер оси (`1` – для оси $Ox$, 2 – для оси $Oy$), а далее в виде вектора указываются деления на оси. В нашем случае логично сделать деления от 0 до 350 с шагом 20, поэтому нужная строка будет выглядеть так: 

```{r, eval=FALSE}
axis(2, at = seq(from = 0, to = 350, by = 20))
```

Эта функция накладывает на уже построенный график новые оси. Если редактируем оси с помощью `axis()`, важно не забыть убрать оси на исходном графике, иначе новые оси наложатся на старые, и это будет выглядеть странно. Для этого в функции `barplot()` нужно добавить аргумент `axes=FALSE`.

```{r, eval=FALSE}
barplot(table(tree$ftype), 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частота", 
        axes = FALSE)
axis(2, at = seq(from = 0, to = 350, by = 20))
```

```{r, include=FALSE}
dev.copy(png, "barplot2.png")
barplot(table(tree$ftype), 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частота", 
        axes = FALSE)
axis(2, at = seq(from = 0, to = 350, by = 20))
dev.off()
```

**Внимание:** строка с `axis()` должна идти сразу после кода для построения самого графика, иначе R не поймёт, к какому графику она относится, и выдаст ошибку. 

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{barplot2.png}
\end{figure}

А что если мы захотим получить столбиковую диаграмму, но не с абсолютными частотами (число деревьев), а с относительными частотами в процентах?

Всё просто: чтобы построить такой график, нужно создать таблицу с частотами в процентах – взять таблицу, полученную с помощью `table()`, поделить все частоты в ней на сумму значений и умножить на 100:

```{r}
tab <- table(tree$ftype)/sum(table(tree$ftype)) * 100
```

Проверим:

```{r, eval=FALSE}
barplot(tab, 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частота (в %)", 
        axes = FALSE)
axis(2, at = seq(from = 0, to = 33, by = 3))
```

```{r, include=FALSE}
dev.copy(png, "barplot3.png")
barplot(tab, 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частота (в %)", 
        axes = FALSE)
axis(2, at = seq(from = 0, to = 50, by = 3))
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{barplot3.png}
\end{figure}

А чтобы было совсем здорово, добавим подписи с процентами на сам график. Для этого сначала создадим вектор с подписями – округлим значения в `tab` и «приклеим» к каждому значению символ `%`. 

Округляем:

```{r}
perc <- round(table(tree$ftype)/sum(table(tree$ftype)) * 100, 2)
```

Для «приклеивания» символа `%` воспользуемся функцией `paste()`, она используется для склеивания строк, но умеет склеивать числовые векторы со строками. Посмотрим на отвлечённый пример:

```{r}
paste("group", c(171, 172, 173, 174))
```

В примере выше функция `paste()` к слову "group" доклеила номера групп из числового вектора. По умолчанию в качестве разделителя используется пробел.

Вернёмся к нашему графику. К каждому элементу вектора `perc` нам нужно приклеить `%`, причём без пробела и иных символов. 

```{r}
# sep - separator
perc_labels <- paste(perc, "%", sep="")
```

Теперь нанесем всё на график – добавим нужный нам текст. Это можно сделать с помощью функции `text()`, только сначала нужно сохранить график в переменную. Сохраним его в переменную `p`, а потом укажем её в качестве аргумента в функции `text()`:

```{r, eval=FALSE}
p <- barplot(tab, 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частоты",
        axes = FALSE)
axis(2, at = seq(from = 0, to = 50, by = 3))
text(x = p, y = perc, labels = perc_labels, 
     pos = 1, col = "white", face = 2)
```

```{r, include=FALSE}
dev.copy(png, "barplot4.png")
p <- barplot(tab, 
        main = "Хвойные деревья",
        col = c("forestgreen", "green4", "springgreen3",
                "springgreen4"),
        xlab = "Виды деревьев",
        ylab = "Частоты",
        axes = FALSE)
axis(2, at = seq(from = 0, to = 50, by = 3))
text(x = p, y = perc, labels = perc_labels, 
     pos = 1, col = "white", face = 2)
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{barplot4.png}
\end{figure}

Здесь в `text()` в качестве координат наносимого текста по оси `x` мы используем значения из самого графика `p`, в качестве координат текста по оси `y` используем значения процентов для каждого столбца из `perc`. Затем указываем сам текст (аргумент `labels`) и сообщаем R, что текст должен размещаться над точкой с заданными координатами (`pos=1`) и что цвет текста должен быть белым. Плюс, добавив аргумент `face=2`, мы сделали шрифт подписей полужирным.

## Визуализация качественных данных: круговая диаграмма

Круговая диаграмма (*pie chart*) строится для относительных частот – для процентов. Таблицу для процентов мы уже построили (`perc`).

```{r, eval=FALSE}
pie(perc)
```

```{r, include=FALSE}
dev.copy(png, "pie1.png")
pie(perc)
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{pie1.png}
\end{figure}

Пока выглядит грустно. Начинаем исправлять. Создадим и добавим вектор цветов для диаграммы:

```{r, eval=FALSE}
pie(perc, col = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
    main = "Хвойные деревья")
```

```{r, include=FALSE}
dev.copy(png, "pie2.png")
pie(perc, col = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
    main = "Хвойные деревья")
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{pie2.png}
\end{figure}

Сильно красивее не стало.

\newpage

Поэтому сделаем по-другому: на самом графике подпишем проценты (`perc_labels`), а остальное вынесем в легенду графика.

**Внимание:** как в случаях с `axis()` и `text()` прописываем функцию для легенды `legend()` сразу после построения графика.

```{r, eval=FALSE}
pie(perc, col = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
    main = "Хвойные деревья", 
    labels = perc_labels)

legend(x = 0.5, y = 1, as.character(unique(tree$ftype)), 
       fill = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
       cex = 0.6)
```
```{r, include=FALSE}
dev.copy(png, "pie3.png")
pie(perc, col = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
    main = "Хвойные деревья на базаре", 
    labels = perc_labels)

legend(x = 0.5, y = 1, as.character(unique(tree$ftype)), 
       fill = c("forestgreen", "darkolivegreen1", "springgreen3",
                  "lightseagreen"),
       cex = 0.6)
dev.off()
```

\begin{figure}[ht!]
\centering
\includegraphics[height=6cm]{pie3.png}
\end{figure}

Так же как и в случае с `text()`, здесь мы сначала указываем координаты для легенды (аргументы `x` и `y`), потом значения, которые должны быть в ней указаны (уникальные значения столбца `ftype`), и цвета, которые им соответствуют на графике (`fill`). Аргумент `cex` отвечает за размер шрифта, который по умолчанию равен 1.

## Визуализация количественных данных: гистограмма

Гистограмма – график, который иллюстрирует соответствие между значениями числового показателя и частотой, с которыми эти значения встречаются в данных.

Для начала построим самую простую гистограмму для высоты деревьев (`height`).

```{r, fig.height = 4}
hist(tree$height)
```

Теперь сделаем её красивой: добавим заголовок графика, поменяем цвет и подпишем оси. Для разнообразия все подписи сделаем на английском:

```{r, fig.height = 4}
hist(tree$height,
     col = "lightgreen", 
     main = "Histogram of height",
     xlab = "Height (in cm)", 
     ylab = "Counts")
```

Что показывает эта гистограмма? Форму распределения высоты деревьев. По гистограмме видно следующее:

* распределение можно считать симметричным относительно среднего значения;
* меньше всего низких деревьев (высота 60-100 см) и высоких (более 240 см);
* если не рассматривать низкие и высокие деревья, распределение похоже на равномерное — шансы встретить деревья высотой 120-140 см примерно такие же, что и встретить деревья высотой 140-160 см, 160-180 см и так далее.

При построении гистограмм можно задействовать важный параметр – `breaks`, число «разбивок», то есть «перегородок», которые нужно взять, чтобы поделить упорядоченную выборку на равные интервалы. Нетрудно догадаться, что число самих равных интервалов всегда будет на 1 меньше, чем число «перегородок».

**Пример:**

|2 2 | 3 5 | 6 8 | 9 10|

breaks = 5

число интервалов = 4 (число столбцов в гистограмме)

Сравним две гистограммы:

```{r, fig.height = 4}
hist(tree$height,
     col = "lightgreen", 
     breaks = 20)
```

```{r, fig.height = 4}
hist(tree$height,
     col = "lightgreen", 
     breaks = 5)
```

Гистограммы внешне отличаются друг от друга. Но, на самом деле, это одна и та же гистограмма, просто с разными интервалами разбивки. На первой гистограмме ширина столбца равна 10, а на второй – 50. Как правило, вопрос о том, какое число столбцов гистограммы взять, не возникает, потому что R автоматически подбирает подходящее число столбцов. (По умолчанию используется алгоритм Cтёржеса, кому интересно почитать про различные алгоритмы, см. [здесь](https://en.wikipedia.org/wiki/Histogram), *Number of bins and width*). Да, это Википедия, но там есть ссылки на оригинальные статьи про способы разбивки.

## Визуализация количественных данных: ящик с усами

С помощью ящика с усами также можно представить распределение количественного показателя. В отличие от гистограммы, ящик с усами позволяет явно увидеть описательные статистики, посчитанные по выборке. Подробнее см. [здесь](https://ru.wikipedia.org/wiki/%D0%AF%D1%89%D0%B8%D0%BA_%D1%81_%D1%83%D1%81%D0%B0%D0%BC%D0%B8).

```{r, fig.height = 5}
boxplot(tree$height, col = "lightgreen")
```

Ящик с усами позволяет также определить, есть ли в выборке нетипичные значения (выбросы, *outliers*), то есть значения, которые сильно отличаются от остальных и располагаются за пределами «усов» графика. В нашем случае таких наблюдений нет. К сожалению, с помощью стандартной функции `boxplot()` мы не сможем отметить на графике, что это за регионы. Но к более «продвинутым» ящикам с усами мы еще вернёмся, когда будем работать с библиотекой ggplot2.

## Визуализация количественных данных: cкрипичная диаграмма

Еще один тип графика, который используется для визуализаии распределения количественных данных, это скрипичная диаграмма (*violin plot* или *bean plot* или *vase plot*). Чтобы понять, почему у графика такие специфические названия, давайте его построим.

Установим сначала библиотеку `vioplot`.

```{r, eval=FALSE}
install.packages("vioplot")
```

И обратимся к ней.

```{r, message=FALSE, warning=FALSE}
library(vioplot)
```

Построим диаграмму для `height`:

```{r, fig.height = 5}
vioplot(tree$height)
```

Получился питон, который проглотил ящик с усами! На самом деле, скрипичная диаграмма объединяет два графика: ящик с усами и график плотности распределения (сглаженный вариант гистограммы – если повернем график на 90 градусов, увидим, что он состоит из двух одинаковых половинок, похожих на обведенную по контуру гистограмму). Несмотря на то, что график кажется необычным, он часто бывает достаточно полезен, особенно, когда нам важно показать форму распределения. По обычному ящику с усами мы бы поняли только, что распределение симметрично и что выбросов нет, а по скрипичной диаграмме мы видим, что распределение похоже на равномерное — перепадов частот не наблюдается, они примерно одинаковы для всех значений.
