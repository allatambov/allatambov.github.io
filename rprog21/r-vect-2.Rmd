---
title: "Основы программирования в R"
subtitle: "Векторы в R: часть 2"
author: "Алла Тамбовцева, НИУ ВШЭ"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
mainfont: CMU Serif
header-includes:
- \usepackage[russian]{babel}
- \usepackage{hyperref}
- \hypersetup{colorlinks = true, urlcolor = blue, linkcolor=magenta}
---

## Последовательности

Для создания векторов можно использовать последовательности (для владеющих Python: аналог `range()` и `arange()`, но в отличие от Python, здесь в вектор включаются оба конца). Например, последовательность из целых значений от 0 до 11:

```{r}
0:11
```

А вот последовательность из целых начений от 10 до 20 с шагом 3:

```{r}
seq(from = 10, to = 20, by = 3)
```

Названия аргументов, если мы сохраняем их порядок, можно опустить:

```{r}
seq(10, 20, 3)
```

Шаг в последовательности необязательно должен быть целым, он может быть дробным:

```{r}
seq(10, 20, 0.5)
```

## Векторы из повторяющихся значений

В R можно быстро составить вектор из повторяющихся значений. Например, три раза повторить "Repeat me":

```{r}
rep("Repeat me", 3)
```

Или четыре раза повторить вектор с двумя значениями 0 и 1: 

```{r}
rep(c(0, 1), 4)
```

А можно попросить повторить каждое из значений вектора по четыре раза:

```{r}
rep(c(0, 1), each = 4)
```

## Поиск уникальных значений и подсчет значений

А как получить вектор без повторяющихся значений? Для этого есть функция `unique()`:

```{r}
p <- c(0, 4, 0, 6, 7, 4)
unique(p)
```

Как посчитать, сколько раз в векторе встречаются различные значения? Для этого есть функция `table()`:

```{r}
table(p)
```

Если нас интересуют не абсолютные частоты, а доли значений, можно воспользоваться функцией `prop.table()`:

```{r}
prop.table(p)
```

Переведём доли в проценты:

```{r}
prop.table(p) * 100
```

## Пропущенные значения

Можно создавать векторы с пропущенными значениями `NA`, от английского *not applicable*:

```{r}
q <- c(0, 1, NA, NA)
q
```

Проверим, являются ли элементы пропущенными значениями:

```{r}
is.na(q)
```

Выведем индексы пропущенных значений:

```{r}
which(is.na(q))
```

Обычное равенство тут не сработает (вспомните про `None` в Python):

```{r}
which(q == NA)
```

Обратите внимание: `NA` указывается без кавычек! Это не текст, который кодирует пропущенные значения, а особый «тип» данных; наличие `NA` не изменяет тип переменной, то есть, если `NA` встречаются в числовой переменной, переменная будет восприниматься R как числовая.

Наличие `NA` в векторе мешает выполнять некоторые действия с ним. Попробуем вычислить среднее значение по `q`:

```{r}
mean(q)
```

Не получилось! Поэтому нужно задействовать дополнительный аргумент `na.rm` (от *NA remove*):

```{r}
mean(q, na.rm = TRUE)
```

Это будет актуально и для других функций, которые вычисляют числовые характеристики, например, `min()`:

```{r}
min(q, na.rm = TRUE)
```

