---
title: "Основы программирования в R"
subtitle: "Основы работы с датафреймами"
author: "Алла Тамбовцева, НИУ ВШЭ"
output:
  pdf_document: 
    toc: true
  html_document:
    df_print: paged
header-includes:
- \usepackage[russian]{babel}
- \usepackage{graphics}
- \usepackage{hyperref}
- \hypersetup{colorlinks = true, urlcolor = blue, linkcolor = magenta}
---

Загрузим данные из файла `tree` с учетом кодировки и вида ячеек с пропущенными значениями:

```{r}
tree <- read.csv("/Users/allat/Desktop/firtree.csv", 
                 encoding = "UTF-8", na.strings = "")
```

## Выбор столбцов и строк датафрейма по названию и номеру

Как мы уже видели, столбец из датафрейма можно выбрать, воспользовавшись оператором `$` и указав после него название столбца:

```{r}
head(tree$wish)  # первые несколько значений
```

Мы можем «закрепить» датафрейм с помощью функции `attach()`, чтобы обращаться к переменным более простым способом: 

```{r}
attach(tree)
head(wish)  # имя переменной как есть, без $
```

Однако это не всегда удобно, особенно если приходится работать с несколькими датафреймами одновременно (наложение переменных с одинаковыми именами, проблемы с редактированием и прочее). Вернем обратно:

```{r, eval=FALSE}
detach(tree)
head(wish)  # теперь эта строчка выдает ошибку
```

Столбец можно выбрать и по номеру, главное помнить, что нумерация в R начинается с 1:

```{r, eval=FALSE}
# третий столбец
tree[3]
```

Если в квадратных скобках после названия датафрейма указано одно число, R автоматически распознает его как номер столбца. В более общем случае указываются два индекса через запятую: номер строки и номер столбца. Если нас интересует только третий столбец, можем на месте строки ничего не писать:

```{r, eval=FALSE}
tree[, 3]
```

Можем выбрать несколько столбцов подряд и сохранить их в новый датафрейм:

```{r}
tree2 <- tree[, 3:5]
```

В R, в отличие от Python, правый конец среза тоже включается, поэтому в примере выше в `tree2` мы сохранили третий, четвертый и пятый столбец из `tree`.

Если выбираем столбцы не подряд, обязательно их номера нужно оформить в виде вектора:

```{r, eval=FALSE}
tree[c(3, 5)]
```

В противном случае получится совсем не то:

```{r}
tree[3, 5]
```

Это «совсем не то» связано с тем, что, когда мы указываем в квадратных скобках числа через запятую, R воспринимает первое число как номер строки, второе число — как номер столбца (как в матрицах — сначала строка, потом столбец). Можем посмотреть на датафрейм и убедиться в этом.

Если нас интересует определенная строка, то ее индекс стоит указать на первом месте, а место для индекса столбца оставить пустым:

```{r}
tree[3, ]
```

Можно совместить — выбрать сразу несколько строк и несколько столбцов:

```{r, eval=FALSE}
tree[1:12, 2:4]
```

## Названия столбцов и строк и их переименование

Чтобы получить вектор названий столбцов датафрейма, нам понадобится функция `colnames()`:

```{r}
colnames(tree)
```

Этот вектор можно использовать для переименования столбцов. Переименуем первый столбец — назовем его `id`:

```{r}
colnames(tree)[1] <- "id"
colnames(tree)
```

Для строк есть похожая функция — `rownames()`:

```{r, eval=FALSE}
rownames(tree)
```

## Фильтрация строк по условиям

Если хотим отобрать из датафрейма определенные наблюдения, это тоже можно сделать с помощью квадратных скобок. Например, мы хотим отобрать строки, соответствующие деревьям, оцененным выше, чем на 3 балла, и сохранить их в датафрейм `good`:

```{r}
good <- tree[tree$score > 3,]
```

Тут важно не забыть поставить запятую, чтобы R понимал, что мы накладываем условие на строки, а столбцы берем все. 

Теперь выберем строки, соответствующие деревьям, которые респонденты хотели бы себе в подарок, и выведем их на экран в отдельной вкладке через `View()`:

```{r, eval=FALSE}
View(tree[tree$wish == "да",])
```

Для примера одновременно отберем только третий и четвертый столбцы:

```{r, eval=FALSE}
View(tree[tree$wish == "да", 3:4])
```

Как обычно, для объединения условий используются операторы `&` (одновременные условия) и `|` (хотя бы одно верно). Выберем строки, соответствующие деревьям, за которые посетители готовы заплатить более 1500 рублей, и которые оценили выше, чем на 4:

```{r, eval=FALSE}
tree[tree$expenses > 1500 & tree$score > 4,]
```

А теперь выберем только сосны, либо сосны Крым, либо датские сосны:

```{r, eval=FALSE}
tree[tree$ftype == "сосна Крым" | tree$ftype == "сосна датская",]
```

## Удаление строк с пропущенными значениями

Напоследок избавимся от строк с пропущенными значениями:

```{r}
tree <- na.omit(tree)
```

